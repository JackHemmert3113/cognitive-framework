/**
 * Shared dual-mode implementation used by ai-core and ai-dual-mode
 *
 * Reusable architecture for AI-enhanced developer tools
 * Supports IDE mode (context generation) and API mode (direct AI integration)
 */

const fs = require('fs').promises;
const path = require('path');
const { validateProcessor, validateConfig } = require('./validation');

function hasPackage(pkg) {
  try {
    require.resolve(pkg);
    return true;
  } catch (err) {
    return false;
  }
}

class AIDualMode {
  constructor(options = {}) {
    this.toolName = options.toolName || 'AI Tool';
    this.version = options.version || '1.0.0';
    this.config = options.config || {};
    this.mode = this.detectMode(options);
    this.processor = options.processor;
    this.modeHandler = null;
  }

  detectMode(options) {
    // Explicit mode takes precedence
    if (options.mode) {
      return options.mode;
    }

    // Check for API mode indicators
    if (process.env.COGNITIVE_API_KEY ||
        process.env.COGNITIVE_MODE === 'api' ||
        options.config?.api?.apiKey) {
      return 'api';
    }

    // Check for CI environment
    if (process.env.CI || process.env.GITHUB_ACTIONS) {
      return 'ci';
    }

    // Default to IDE mode
    return 'ide';
  }

  async initialize() {
    console.log(`🔧 Initializing ${this.toolName} in ${this.mode.toUpperCase()} mode...`);

    const modes = {
      'ide': IDEMode,
      'api': APIMode,
      'ci': CIMode
    };

    const ModeClass = modes[this.mode];
    if (!ModeClass) {
      throw new Error(`Unknown mode: ${this.mode}`);
    }

    this.modeHandler = new ModeClass({
      ...this.config[this.mode],
      toolName: this.toolName
    });

    return this;
  }

  async process(data) {
    if (!this.modeHandler) {
      await this.initialize();
    }

    if (!this.processor) {
      throw new Error('No processor provided. Please provide a processor with analyzeForIDE and/or prepareForAPI methods.');
    }

    // Validate processor
    const validationErrors = validateProcessor(this.processor);
    if (validationErrors.length > 0) {
      throw new Error(`Invalid processor: ${validationErrors.join(', ')}`);
    }

    // Validate config for the current mode
    const configErrors = validateConfig(this.config, this.mode);
    if (configErrors.length > 0) {
      throw new Error(`Invalid configuration: ${configErrors.join(', ')}`);
    }

    return this.modeHandler.process(data, this.processor);
  }

  // Static factory method for convenience
  static create(toolName, processor, options = {}) {
    return new AIDualMode({
      toolName,
      processor,
      ...options
    });
  }
}

/**
 * IDE Mode - Generates context files for IDE AI assistants
 */
class IDEMode {
  constructor(config = {}) {
    this.config = config;
    this.toolName = config.toolName;
    this.outputDir = config.outputDir || '.ai';
  }

  async process(data, processor) {
    console.log(`📝 ${this.toolName} - IDE Mode: Generating AI context files...`);

    // Ensure processor has required method
    if (!processor.analyzeForIDE) {
      throw new Error('Processor must implement analyzeForIDE method for IDE mode');
    }

    // Let the tool process the data
    const processed = await processor.analyzeForIDE(data);

    // Validate processed data
    this.validateProcessedData(processed);

    // Generate standard outputs
    const files = await this.generateContextFiles(processed);

    return {
      mode: 'ide',
      status: 'success',
      files,
      instructions: this.getInstructions(files)
    };
  }

  validateProcessedData(processed) {
    if (!processed.context) {
      throw new Error('Processor must return a context object');
    }
    if (!processed.analysis) {
      throw new Error('Processor must return an analysis string');
    }
  }

  async generateContextFiles(processed) {
    await fs.mkdir(this.outputDir, { recursive: true });

    const timestamp = new Date().toISOString();
    const files = {
      [`${this.outputDir}/context.json`]: JSON.stringify({
        tool: this.toolName,
        timestamp,
        ...processed.context
      }, null, 2),
      [`${this.outputDir}/analysis.md`]: this.wrapAnalysis(processed.analysis, timestamp),
      [`${this.outputDir}/prompts.md`]: this.generatePrompts(processed)
    };

    // Add IDE-specific files if enabled
    if (this.config.includeIDESpecific !== false) {
      files[`${this.outputDir}/copilot-guide.md`] = this.generateCopilotGuide(processed);
      files[`${this.outputDir}/cursor-hints.json`] = this.generateCursorHints(processed);
    }

    // Write all files
    for (const [filepath, content] of Object.entries(files)) {
      await fs.writeFile(filepath, content);
    }

    return Object.keys(files);
  }

  wrapAnalysis(analysis, timestamp) {
    return `# ${this.toolName} Analysis
Generated: ${timestamp}

${analysis}

---
*Generated by AI Dual Mode - Use with your IDE's AI assistant*
`;
  }

  generatePrompts(processed) {
    const customPrompts = processed.prompts || '';

    return `# AI Assistant Prompts - ${this.toolName}

## Universal Prompts (Works with any AI assistant)

### 1. Analyze Context
\`\`\`
Review ${this.outputDir}/context.json and provide detailed insights
\`\`\`

### 2. Suggest Improvements
\`\`\`
Based on ${this.outputDir}/analysis.md, suggest specific improvements
\`\`\`

### 3. Generate Solutions
\`\`\`
Using the context in ${this.outputDir}/context.json, generate code to address the issues
\`\`\`

## Quick Copy Commands

**Full Analysis:**
"Analyze all files in ${this.outputDir}/ and create an action plan"

**Priority Issues:**
"Review ${this.outputDir}/context.json and fix the most critical issues first"

**Best Practices:**
"Check ${this.outputDir}/analysis.md and suggest architecture improvements"

## Tool-Specific Prompts

${customPrompts}

---
*Tip: These prompts work with GitHub Copilot, Cursor, Windsurf, and other AI coding assistants*
`;
  }

  generateCopilotGuide(processed) {
    return `# GitHub Copilot Guide - ${this.toolName}

## Context
This project uses ${this.toolName} with AI Dual Mode.
Current analysis available in \`../${this.outputDir}/\`

## Your Task
1. Review the context.json for current state
2. Check analysis.md for identified issues  
3. Follow the suggestions to improve the codebase

## Patterns to Follow
${processed.patterns || '- Follow existing code style\n- Maintain consistency\n- Add appropriate tests'}

## Priority Areas
${processed.priorities || '1. Critical fixes\n2. Performance improvements\n3. Code quality'}
`;
  }

  generateCursorHints(processed) {
    return JSON.stringify({
      version: '1.0',
      tool: this.toolName,
      hints: processed.hints || [],
      context: {
        files: [`${this.outputDir}/context.json`, `${this.outputDir}/analysis.md`],
        priority: 'high'
      }
    }, null, 2);
  }

  getInstructions(files) {
    return `
✅ AI Context Files Generated Successfully!

📁 Created ${files.length} files for your IDE's AI assistant:
${files.map(f => `   • ${f}`).join('\n')}

📖 How to use:
1. Open any generated file in your IDE
2. Invoke your AI assistant (Copilot, Cursor, etc.)
3. Use prompts from ${this.outputDir}/prompts.md
4. Let AI help you improve your code!

💡 Tips:
- Add ${this.outputDir}/ to .gitignore if you don't want to commit these files
- Regenerate context anytime by running the tool again
- Customize prompts for your specific needs

🔗 Works with: GitHub Copilot, Cursor, Windsurf, JetBrains AI, and more!
`;
  }
}

/**
 * API Mode - Direct AI integration for automation
 */
class APIMode {
  constructor(config = {}) {
    this.config = config;
    this.toolName = config.toolName;
    this.provider = config.provider || 'openai';
    this.apiKey = config.apiKey || process.env.COGNITIVE_API_KEY;

    if (!this.apiKey) {
      throw new Error(`API key required for API mode. Set via config.apiKey or COGNITIVE_API_KEY environment variable`);
    }

    this.initializeProvider();
  }

  initializeProvider() {
    switch (this.provider) {
      case 'openai':
        if (!hasPackage('openai')) {
          console.warn('OpenAI package not installed. Using mock provider. Run: npm install openai');
          this.useMockProvider();
        } else {
          const OpenAI = require('openai');
          this.client = new OpenAI({ apiKey: this.apiKey });
        }
        break;
      case 'anthropic':
        if (!hasPackage('@anthropic-ai/sdk')) {
          console.warn('Anthropic package not installed. Using mock provider. Run: npm install @anthropic-ai/sdk');
          this.useMockProvider();
        } else {
          const { Anthropic } = require('@anthropic-ai/sdk');
          this.client = new Anthropic({ apiKey: this.apiKey });
        }
        break;
      case 'local':
        // Future implementation for local LLMs
        throw new Error('Local LLM support coming soon');
      case 'mock':
        this.useMockProvider();
        break;
      default:
        throw new Error(`Unsupported AI provider: ${this.provider}`);
    }
  }

  useMockProvider() {
    this.provider = 'mock';
    this.client = {
      chat: {
        completions: {
          create: async () => ({
            choices: [{ message: { content: '[mock response]' } }]
          })
        }
      }
    };
  }

  async process(data, processor) {
    console.log(`🤖 ${this.toolName} - API Mode: Processing with ${this.provider}...`);

    // Ensure processor has required methods
    if (!processor.prepareForAPI) {
      throw new Error('Processor must implement prepareForAPI method for API mode');
    }
    if (!processor.processAIResponse) {
      throw new Error('Processor must implement processAIResponse method for API mode');
    }

    try {
      // Let the tool prepare data for API
      const prepared = await processor.prepareForAPI(data);

      // Validate prepared data
      this.validatePreparedData(prepared);

      // Send to AI
      const aiResponse = await this.callAI(prepared);

      // Let tool handle AI response
      const result = await processor.processAIResponse(aiResponse, data);

      return {
        mode: 'api',
        status: 'success',
        result,
        metadata: {
          provider: this.provider,
          model: this.config.model || 'gpt-4',
          timestamp: new Date().toISOString(),
          usage: prepared.usage
        }
      };
    } catch (error) {
      return {
        mode: 'api',
        status: 'error',
        error: error.message,
        metadata: {
          provider: this.provider,
          timestamp: new Date().toISOString()
        }
      };
    }
  }

  validatePreparedData(prepared) {
    if (!prepared.messages || !Array.isArray(prepared.messages)) {
      throw new Error('prepareForAPI must return an object with messages array');
    }
    if (prepared.messages.length === 0) {
      throw new Error('messages array cannot be empty');
    }
  }

  async callAI(prepared) {
    const requestOptions = {
      model: this.config.model || 'gpt-4',
      messages: prepared.messages,
      temperature: prepared.temperature ?? 0.3,
      max_tokens: prepared.maxTokens || 2000
    };

    // Add response format if specified
    if (prepared.responseFormat) {
      requestOptions.response_format = prepared.responseFormat;
    }

    const response = await this.client.chat.completions.create(requestOptions);

    return response.choices[0].message.content;
  }
}

/**
 * CI Mode - Optimized for continuous integration
 */
class CIMode {
  constructor(config = {}) {
    this.config = config;
    this.toolName = config.toolName;
    this.outputFormat = config.outputFormat || 'json';
  }

  async process(data, processor) {
    console.log(`🔄 ${this.toolName} - CI Mode: Generating CI-friendly output...`);

    // Use IDE analyzer if no CI-specific one exists
    const analyzerMethod = processor.analyzeForCI || processor.analyzeForIDE;
    if (!analyzerMethod) {
      throw new Error('Processor must implement analyzeForCI or analyzeForIDE method');
    }

    const processed = await analyzerMethod.call(processor, data);

    // Generate CI-appropriate output
    const output = this.formatForCI(processed);

    // Write to stdout for CI systems to capture
    console.log(JSON.stringify(output, null, 2));

    // Also save to file if configured
    if (this.config.saveToFile) {
      await fs.writeFile(
        this.config.outputFile || 'ai-analysis-ci.json',
        JSON.stringify(output, null, 2)
      );
    }

    return output;
  }

  formatForCI(processed) {
    return {
      mode: 'ci',
      status: 'success',
      tool: this.toolName,
      timestamp: new Date().toISOString(),
      summary: processed.context?.summary || 'Analysis complete',
      metrics: processed.context?.metrics || {},
      issues: processed.context?.issues || [],
      passed: !processed.context?.issues?.some(i => i.severity === 'critical')
    };
  }
}

// Export everything needed
/**
 * exported exported API
 * @example
 * exported();
 */
// Added in v1.0
module.exports = {
  AIDualMode,
  IDEMode,
  APIMode,
  CIMode
};
